#!/usr/bin/env python3
import argparse
import logging
import pydoc
from yangvoodoo.SchemaData import Expander

parser = argparse.ArgumentParser(
    description="Combine a YANG schema with a supplied data payload."
)
parser.add_argument("--yang", help="YANG module (should be on YANGPATH)", required=True)
parser.add_argument(
    "--data",
    help="A data tree (default XML) but can be set to JSON with --format",
    type=argparse.FileType("r"),
    required=True,
)
parser.add_argument("--plain", help="Plain Text", action="store_true")
parser.add_argument(
    "--format", help="Data Tree format", choices=["xml", "json"], default="xml"
)
parser.add_argument("--search", help="Initial arguments for less paging", default="")
parser.add_argument("--schema-xpath", help="Show schema xpath's", action="store_true")
parser.add_argument(
    "--data-xpath", help="Show data xpath's against leaves", action="store_true"
)
args = parser.parse_args()

FORMATS = {"xml": 1, "json": 2}


class DullDisplay:
    DIM = ""
    NORMAL = ""
    NORMAL_ = ""
    BRIGHT = ""
    MISSING = ""
    LEAF = "l> "
    CONTAINER = "C> "
    LIST = "L+ "
    LEAF_LIST = "l+ "
    LIST_ELEMENT = "-> "
    MANDATORY = "*"
    WHEN = "! "
    MUST = "% "
    CHOICE = "? "
    CASE = "^ "
    CONSTRAINT = ""

    @staticmethod
    def get_active(active):
        if active:
            return "* "
        return ""


class Display:
    DIM = "\033[2m"
    NORMAL = "\033[22m"
    NORMAL_ = "\033[22m"
    BRIGHT = "\033[1m"
    MISSING = " "
    LEAF = "üçÅ "
    CONTAINER = "ü•° "
    LIST = "üì¶ "
    LIST_ELEMENT = "üì• "
    LEAF_LIST = "üìö "
    MANDATORY = "‚ö† "
    WHEN = "‚ò£ "
    MUST = "‚ò¢ "
    CHOICE = "üîÑ "
    CASE = "üìç "
    CONSTRAINT = "üîç "

    @staticmethod
    def get_active(active):
        if active:
            return "‚ú® "
        return ""

    @staticmethod
    def get_presence(presence):
        if presence:
            return "‚úî "
        return ""


if args.plain:
    Display = DullDisplay


class Yang2Text(Expander):

    INCLUDE_BLANK_LIST_ELEMENTS = True

    def write_title(self, module):
        breakpoint()
        self.result.write(f"{self.yang_module}\n")
        self.result.write(f"{'-'*len(self.yang_module)}\n")
        self.result.write("\n")
        self.result.write(f"{module.description()}")
        self.result.write("\n")
        self.result.write("\n")
        revisions = list(module.revisions())
        for rev in revisions[0:1]:
            self.result.write(f"{rev.date()} {rev.description()}\n\n")

    def _show_when(self, node):
        if node.when_condition():
            self.result.write(Display.BRIGHT)
            for line in node.when_condition().split("\n"):
                when = Display.MUST
                self.result.write(f"{self.get_indent()}      {when}{line}\n")
                when = ""
            self.result.write("\n")
            self.result.write(Display.NORMAL)

    def _show_must(self, node):
        for cond in node.must_conditions():
            self.result.write(Display.BRIGHT)
            for line in cond.split("\n"):
                must = Display.MUST
                self.result.write(f"{self.get_indent()}      {must}{line}\n")
                must = ""
            self.result.write("\n")
            self.result.write(Display.NORMAL)

    def _show_constraints(self, node):
        for constraint in self.get_human_constraints(node):
            self.result.write(Display.BRIGHT)
            self.result.write(
                f"{self.get_indent()}      {Display.CONSTRAINT}{constraint}\n"
            )
            self.result.write(Display.NORMAL)

    def _show_description(self, description):
        if description():
            for line in description().split("\n"):
                self.result.write(f"{self.get_indent()}{Display.DIM}      {line}\n")
            self.result.write("\n")
            self.result.write(Display.NORMAL)

    def callback_open_list(self, node, count, node_id):
        self.result.write(
            f"{self.open_indent()}{Display.LIST} {node.name()} {Display.DIM} ({count} Item{self.pluralise(count)}) {Display.NORMAL}\n"
        )
        self._show_description(node.description)

    def callback_open_list_element(self, node, key_values, empty_list_element, node_id):
        self.result.write(
            f"{self.open_indent()} {Display.NORMAL}{Display.LIST_ELEMENT} \n"
        )

    def callback_close_list_element(self, node):
        self.close_indent()

    def callback_close_list(self, node):
        self.close_indent()

    def _show_paths(self, schema_path, data_path):
        if args.data_xpath:
            self.result.write(
                f"{self.get_indent()}      {Display.DIM}D: {data_path}{Display.NORMAL}\n"
            )
        if args.schema_xpath:
            self.result.write(
                f"{self.get_indent()}      {Display.DIM}S: {schema_path}{Display.NORMAL}\n"
            )
        if args.schema_xpath or args.data_xpath:
            self.result.write("\n")

    def callback_write_leaf(self, node, value, default, key, node_id):
        self.result.write(f"{self.get_indent()} {Display.NORMAL}{Display.LEAF}")
        if node.mandatory():
            self.result.write(f"{Display.MANDATORY} ")
        if default and value and value[1:-1] == default:
            self.result.write(
                f"{node.name()} = {Display.DIM}{value[1:-1]}{Display.NORMAL}"
            )
        elif value[1:-1]:
            self.result.write(f"{node.name()} = {value[1:-1]}")
        else:
            self.result.write(
                f"{node.name()} {Display.DIM} {Display.MISSING} {Display.NORMAL}"
            )

        self.result.write(
            f"{Display.DIM} Type: {', '.join(self.get_human_types(node))} {Display.NORMAL}\n"
        )

        self._show_paths(node.schema_path(), "".join(self.data_path_trail))
        self._show_when(node)
        self._show_constraints(node)
        self._show_description(node.description)

    def callback_open_containing_node(self, node, presence, node_id):
        self.result.write(f"{self.open_indent()} {Display.NORMAL}{Display.CONTAINER} ")
        if presence is not None:
            self.result.write(f"{node.name()} {Display.get_presence(presence)}\n")
        else:
            self.result.write(f"{node.name()}\n")

        self._show_must(node)
        self._show_when(node)
        self._show_description(node.description)

    def callback_close_containing_node(self, node):
        self.close_indent()

    def callback_open_leaflist(self, node, count, node_id):
        self.result.write(
            f"{self.open_indent()} {Display.NORMAL}{Display.LEAF_LIST} {node.name()} - "
        )
        self.result.write(
            f"- {Display.DIM}({count} item{self.pluralise(count)}){Display.NORMAL}"
        )
        self.result.write("\n")
        self._show_description(node.description)

    def callback_close_leaflist(self, node):
        self.close_indent()

    def callback_open_choice(self, node, node_id):
        self.result.write(
            f"{self.open_indent()} {Display.NORMAL}{Display.CHOICE} {node.name()}\n"
        )
        self.open_indent()

    def callback_close_choice(self, node):
        self.close_indent()
        self.close_indent()

    def callback_open_case(self, node, active_case, no_active_case, node_id):
        if not active_case:
            self.result.write(Display.DIM)
            Display.NORMAL = Display.DIM
        self.result.write(
            f"{self.get_indent()}{Display.CASE} {Display.get_active(active_case)} {node.name()}\n"
        )
        self.open_indent()

    def callback_close_case(self, node):
        self.close_indent()
        Display.NORMAL = Display.NORMAL_
        self.result.write(Display.NORMAL)


if __name__ == "__main__":
    log = logging.getLogger("yang2text")
    logging.basicConfig()
    log.setLevel(5)

    generator = Yang2Text(args.yang, log)
    generator.process(args.data.read(), FORMATS[args.format])

    generator.result.seek(0)
    if args.search:
        pydoc.pipepager(generator.result.read(), cmd=f"less -R -i -p {args.search}")
    else:
        pydoc.pipepager(generator.result.read(), cmd=f"less -R -i ")
